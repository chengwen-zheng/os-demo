使用条件变量时，我们要注意唤醒的线程是不受控制的。因此有趣的现象可能发生 (假设 n = 1，但有多个生产者和消费者)：

一个 Tconsume 和一个 Tproduce 同时处于等待状态
此时打印的括号序列为 ...(，此时可以打印一个右括号
此时另一个 Tconsume 开始执行，打印一个右括号，并执行 signal 唤醒一个线程
Tconsume 被唤醒，因此打印出 ...())
我们看到，Tproduce 只希望唤醒消费者；Tconsume 只希望唤醒生产者，因此可以用两个条件变量解决这个问题。

gcc index.c
./a.out 2 2

对比 pc-mutex 观察

注意：index-cv-while
在给定的代码中，cond_broadcast是一个函数调用，用于发送一个广播通知给正在等待条件变量的所有线程。

条件变量（condition variable）是一种同步机制，用于在线程之间传递信息和进行线程间的等待和唤醒操作。在这里，cond_broadcast函数用于唤醒所有正在等待条件变量的线程，并通知它们可以继续执行。

具体来说，在Tproduce和Tconsume函数中，线程在等待条件变量cv满足特定条件之前会进入休眠状态，以避免浪费CPU资源。当条件满足时，通过调用cond_broadcast(&cv)来发送一个广播通知，告知所有正在等待条件变量的线程可以继续执行。

使用cond_broadcast可以确保所有等待线程同时被唤醒，而不仅仅是唤醒一个或一部分线程。这有助于避免竞争条件，并确保所有线程有机会继续执行。

需要注意的是，cond_broadcast函数的调用必须在互斥锁（mutex）lk已经被持有的情况下进行，以确保线程在调用cond_broadcast之前已经获得了正确的同步保护。
