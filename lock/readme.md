1. spin-lock-demo
   这段代码是一个简单的自旋锁的实现，它使用了一个整型变量 flag 来表示锁的状态，其中 flag 的值为 0 表示锁可用，为 1 表示锁已经被占用。

   其中函数 TestAndSet 是一个原子操作，用于将 old_ptr 指向的变量的值设置为 new，并返回原来的值。这个操作是原子的，也就是说它是不可分割的，其他线程无法在这个操作中间插入。

   函数 init 用于初始化锁的状态，将 flag 的值设置为 0，表示锁可用。

   函数 lock 用于获取锁，当锁被占用时，该函数会进入自旋状态，不断地执行空循环 while (TestAndSet(&lock->flag, 1) == 1)，直到锁被释放并成功占用为止。

   函数 unlock 用于释放锁，将 flag 的值设置为 0，表示锁可用。

   自旋锁是一种基于忙等待的同步机制，它适用于锁被占用的时间短、竞争不激烈的情况。在自旋锁中，当锁被占用时，线程会一直处于忙等待状态，不断地检查锁是否可用，这会占用 CPU 资源。因此，在实际应用中，需要根据具体情况选择合适的同步机制，并对其进行优化和调整，以确保系统的性能和稳定性。

2. load-linked.c
   在这个例子中，我们定义了一个 lock_t 结构体，其中包含一个整型标记 flag，用于表示锁的状态。我们使用 while 循环来等待锁被释放。在每个循环迭代中，我们首先检查 lock->flag 的值是否为 1，如果是，则继续等待；否则，我们使用 \_\_sync_val_compare_and_swap() 函数尝试将 lock->flag 的值从 0 更新为 1。如果更新成功，则代表该线程已经获得了锁，可以直接返回。否则，该线程需要再次尝试获取锁。

在 unlock() 函数中，我们简单地将 lock->flag 的值设置为 0，以释放锁。

我们还定义了一个全局变量 counter，并使用一个简单的自增操作来模拟需要保护的共享资源。我们使用 pthread 库来创建和管理线程。在 increment_counter() 函数中，我们使用 lock() 和 unlock() 函数来保护对 counter 变量的访问。

在 main() 函数中，我们创建了 10 个线程，并为每个线程分配了 1000000 次自增操作。当所有线程完成后，程序会输出计数器的最终值。

需要注意的是，这个例子同样使用了 GCC 内置函数 \_\_sync_val_compare_and_swap()，因此也不是一个纯粹的 load-linked 和 store-conditional 实现。
